part1
01
02
03. 변수 : 변할 수 있는 데이터, 상수 : 변할 수 없는 데이터
		컴퓨터는 2의 보수 방식을 사용한다.
		부호 * 지수 * 유효숫자
04.	scanf : 취약 함수로써 Visual studio에서는 사용 못하게 막아놈
		%(엔펄센트) : 특정 주소의 변수를 저장해 scanf의 기능을 수행 할 수 있게 한다.
		%lf(double)와 %f(float)의 차이점 : lf는 특정 크기를 입력하겠다고 명시, f는 그냥 출력
05.	삼항 연산자 : if(a == b) ? 참 : 거짓 
06. if, switch() case 'A': break default: break
07. for문, while 이중 for문
08.	함수, void : 함수가 반환 값 없을 때, 재귀함수 : factorial fact(int a){return a * fact(a - 1)
09. 배열 : 최대값 찾기, #include <limits.h> : INT_MIN = -20억, 문자열 없음 : 문자 + 배열
10. 포인터 : 어떠한 int형 변수가 있으면 이 변수의 메모리 주소를 저장함 int a = 5; int *b = &a
		다중포인터 : 주소가 닮긴 포인터 변수도 주소값이 있으므로 그것을 가르키는 포인터를 다중포인터
11. 문자 : c언어에서는 1바이트(8bit)로 구성된 아스키코드로 문자를 나타낸다. char, %c, getchar()
		버퍼 : 표준 입출력에서 데이터를 처리할 때 값을 잠시 저장 
12. 문자열 : 문자를 나열한 것, 문자 마지막에 \0 NULL 값이 들어있다. 
		NULL : 문자열의 끝을 알려주기 위함
		#include <string.h> : strlen()길이, strcmp()앞뒤, strcpy()복사, strcat()합침, strstr() 찾기
13. 전역변수, 지역변수 | 함수의 값을 주는 방법, 함수의 주소(*)을 주는 방법 2개가 있다. 
14. 2차원 배열 int a[행][열]
		C언어의 배열 ~= 포인터
15. 동적 메모리 할당 : 주소가 변경될 수 있다.
		#include <stdlib.h> malloc(sizeof(int))
		#include <string.h> memset(포인터, 값, 크기);
		동적 메모리 할당 : 2차원 배열, 2차원 포인터 활용하기 | int **p = (int**)malloc((int*)*3);
		free() : 할당된 메모리를 없애줘야됨 : 메모리 누수 발생
16. 함수 포인터 : 함수를 가르키는 주소를 담는 포인터
17. 구조체 : 객체들을 묶어 놓은 것들 
18. 파일 입출력 : 데이터의 저장, 꼭 닫아야한다. 
19. 전처리기 : 독립적으로 처리됨, 
		#include<"파일이름> : 꺽쇠는 시스템 디렉토리에서 불옴
		#include "파일이름" : 현재 폴더에서 파일을 가져옴
    매크로 전처리기 : #define 으로 정의한다. 
				소스코드의 양도 줄일 수 있다 :	#define ll long long
										#define ld long double
	조건부 컴파일 : 디버깅과 소스코드의 이식성을 높여준다 : #ifndef ~ #endif
	파일 분할 컴파일 : 체계적인 헤더파일 만들기, 헤더파일을 .c와 .h로 분리한다.
20. 자료구조 : 데이터를 효과적으로 저장하고 관리함
	
	선형구조 : 배열, 연결 리스트, 스택, 큐
	비선형 구조 : 트리, 그래프
	
	자료구조 & 알고리즘 : 효율적이게 작성하기 위함
	
	시간 복잡도 : 연산횟수		
	공간 복잡도 : 메모리양		|시간과 공간은 반비례 관계이다. 
21. 연결 리스트 : 리스트에 데이터를 추가, 삭제할 때 비효율 적이다.
	단일 연결 리스트 : 배열에 비해서 삽입/삭제가 간단함. 
				  특정 인덱스 접근을 못함.
				  포인터로 인한 메모리 공간 낭비
22. 









