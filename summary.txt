part1
01
02
03. 변수 : 변할 수 있는 데이터, 상수 : 변할 수 없는 데이터
		컴퓨터는 2의 보수 방식을 사용한다.
		부호 * 지수 * 유효숫자
04.	scanf : 취약 함수로써 Visual studio에서는 사용 못하게 막아놈
		%(엔펄센트) : 특정 주소의 변수를 저장해 scanf의 기능을 수행 할 수 있게 한다.
		%lf(double)와 %f(float)의 차이점 : lf는 특정 크기를 입력하겠다고 명시, f는 그냥 출력
05.	삼항 연산자 : if(a == b) ? 참 : 거짓 
06. if, switch() case 'A': break default: break
07. for문, while 이중 for문
08.	함수, void : 함수가 반환 값 없을 때, 재귀함수 : factorial fact(int a){return a * fact(a - 1)
09. 배열 : 최대값 찾기, #include <limits.h> : INT_MIN = -20억, 문자열 없음 : 문자 + 배열
10. 포인터 : 어떠한 int형 변수가 있으면 이 변수의 메모리 주소를 저장함 int a = 5; int *b = &a
		다중포인터 : 주소가 닮긴 포인터 변수도 주소값이 있으므로 그것을 가르키는 포인터를 다중포인터
11. 문자 : c언어에서는 1바이트(8bit)로 구성된 아스키코드로 문자를 나타낸다. char, %c, getchar()
		버퍼 : 표준 입출력에서 데이터를 처리할 때 값을 잠시 저장 
12. 문자열 : 문자를 나열한 것, 문자 마지막에 \0 NULL 값이 들어있다. 
		NULL : 문자열의 끝을 알려주기 위함
		#include <string.h> : strlen()길이, strcmp()앞뒤, strcpy()복사, strcat()합침, strstr() 찾기
13. 전역변수, 지역변수 | 함수의 값을 주는 방법, 함수의 주소(*)을 주는 방법 2개가 있다. 
14. 2차원 배열 int a[행][열]
		C언어의 배열 ~= 포인터
15. 동적 메모리 할당 : 주소가 변경될 수 있다.
		#include <stdlib.h> malloc(sizeof(int))
		#include <string.h> memset(포인터, 값, 크기);
		동적 메모리 할당 : 2차원 배열, 2차원 포인터 활용하기 | int **p = (int**)malloc((int*)*3);
		free() : 할당된 메모리를 없애줘야됨 : 메모리 누수 발생
16. 함수 포인터 : 함수를 가르키는 주소를 담는 포인터
17. 구조체 : 객체들을 묶어 놓은 것들 
18. 파일 입출력 : 데이터의 저장, 꼭 닫아야한다. 
19. 전처리기 : 독립적으로 처리됨, 
		#include<"파일이름> : 꺽쇠는 시스템 디렉토리에서 불옴
		#include "파일이름" : 현재 폴더에서 파일을 가져옴
    매크로 전처리기 : #define 으로 정의한다. 
				소스코드의 양도 줄일 수 있다 :	#define ll long long
										#define ld long double
	조건부 컴파일 : 디버깅과 소스코드의 이식성을 높여준다 : #ifndef ~ #endif
	파일 분할 컴파일 : 체계적인 헤더파일 만들기, 헤더파일을 .c와 .h로 분리한다.
20. 자료구조 : 데이터를 효과적으로 저장하고 관리함
	
	선형구조 : 배열, 연결 리스트, 스택, 큐
	비선형 구조 : 트리, 그래프
	
	자료구조 & 알고리즘 : 효율적이게 작성하기 위함
	
	시간 복잡도 : 연산횟수		
	공간 복잡도 : 메모리양		|시간과 공간은 반비례 관계이다. 
21. 연결 리스트 : 리스트에 데이터를 추가, 삭제할 때 비효율 적이다.
	단일 연결 리스트 : 배열에 비해서 삽입/삭제가 간단함. 
				  특정 인덱스 접근을 못함.
				  포인터로 인한 메모리 공간 낭비
22. 양방향 연결 리스트 : 앞 노드와, 뒷노드가 있다.  
				  삽입/삭제등 예외 상황을 처리해야한다. 예)더 이상 삭제 불가할 때
23. 스택 : 한쪽으로 들어가서 한쪽으로 나오는 자료구조.
		 배열이나 연결리스트로 2가지 방식으로 구현 가능.

24. 계산기 만들기 : 스택 자료구조로 만들기 
				중위 표기법 : 사람이 수식을 표기할 때 사용하는 표기방법 
						 ->>7 5 * 3 +
 						 예) 7 * 5 + 3
25. 큐 : 뒤쪽으로 들어가서 앞으로 나오는 자료 구조.
		배열이나 연결리스트로 2가지 방식으로 구현 가능.
26. 선택 정렬과 삽입 정렬 : 선택정렬 : 가장 작은 것을 앞으로 보냄.
							 가장 작은것 선택하기 + 앞으로 보내기 = O(N^2)의 시간복잡도를 가짐
					: 삽입 정렬 : 각 숫자를 적절한 위치에 삽입함.
							 들어갈 위치 선택하기 + 선택하는 횟수 = O(N^2)의 시간복잡도를 가짐
27. 퀵 정렬 : 피벗을 기준으로 큰값과 작은 값을 서로 교체후 정률 하는 기법.
			서로 교체 + 반으로 나누어진 원소를 정렬(logN) = NlogN 
28. 계수 정렬 : 크기를 기준으로 데이터의 개수를 세는 정렬 알고리즘, O(N), 크기 제한을 줘야된다.
29. 기수 정렬 : 자릿수를 기준으로 데이터를 정렬하는 알고리즘, O(DN), 
30. 이진 트리 : 트리 : 나뭇가지처럼 생김
				- 루트
				(중간 가지)
				 ㄴ 리프노드 : 맨 밑 노드
				 
				- 부모/자식 관계
				부모트리
				ㄴ 자식트리1, 자식트리2, ...
				
				- 길이 : 목적 노드까지의 가지의 개수
				- 깊이 : 루트에서 부터 특정 노드까지의 길이 
				- 높이 : 맨 밑 루트노드부터 가장 깊은 노드까지의 길이
				
			이진트리 : 최대 2개의 자식을 가질 수 있다.
			포화 이진트리 : 리프노드(맨 윗)를 제외한 모든 노드가 2개의 자식을 가지고 있는 트리
			완전 이진트리 : 왼쪽 노드부터 차근차근 채워진 형태
			높이 균형트리 : 왼쪽 자식과 오른쪽 자식에 트리의 높이 차이가 1이상 차이나지 않는 트리
			
			이진트리의 장점 : 낮은 높이에서 관리할 수 있다는 점에서 데이터 활용의 효율성이 높아짐.
31. 이진트리의 구현 및 순회 : 순회방법(총 3가지)
			- 전위순회 : 자기자신 출력, 왼쪽 자식, 오른쪽 자식, 반복
			- 중위순회 : 왼쪽 자식 줄력, 자기자신 출력, 오른쪽 자식 
					: 그림상 왼쪽에서 부터 차례대로 출력하는 것과 비슷하다. 
32. 우선순위 큐 : 우선순위의 맞게 데이터가 나간다. 우선순위가 높은게 먼저나감
			: 최대 힙을 통해 구현한다.
			최대 힙이란 : 완전 이진트리 여야됨, 부모보다 자식이 더 값이 작아야됨.
			O(NlogN)
33. 순차 탐색와 이진 탐색 
			순차 탐색 : 특정 원소를 찾기 위해서 순차적으로 하나씩 탐색하는 방법, O(N) = 한개씩 검사
			이진 탐색 : 내부에 데이터가 이미 정렬되어 있음, 반으로 나눠서 한쪽만 탐색
				

34. 그래프의 개념과 구현 : 그래프 : 사물의 정점(노드)과 간선(엣지)으로 나타내기 위한도구
					그래프는 인접행렬(2차원배열을 사용), 인접리스트(리스트를 사용)
 						(3)	(7)
					   1       2
					답) 	0 3 7
						3 0 무한
						7 무한 0 
				  무방향 그래프 : 모든 간선이 방향성을 갖지 않는 그래프
				  비가중치 그래프 : 모든 간선의 가중치가 없는 그래프
				  
				  방향 그래프 : 모든 간선이 방향성을 갖는 그래프
				  가중치 그래프 : 모든 간선의 가중치가 있는 그래프







